// File generated by the BNF Converter (bnfc 2.9.4.1).

package org.stella.typecheck;

import org.antlr.runtime.EarlyExitException;
import org.syntax.stella.Absyn.*;
import org.syntax.stella.Absyn.Record;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitTypeCheck {
    public class ProgramVisitor<R, A> implements Program.Visitor<R, A> {
        public R visit(AProgram p, A arg) {
            if (!p.listextension_.isEmpty()) {
                for (String name : ((AnExtension) p.listextension_.get(0)).listextensionname_) {
                    if (name.equals("#structural-subtyping")) {
                        Declarations.subtypeEnabled = true;
                    }
                    if (name.equals("#ambiguous-type-as-bottom")) {
                        Declarations.huiEnabled = true;
                    }
                    if (name.equals("#type-reconstruction")) {
                        Declarations.autoEnabled = true;
                    }
                    if (name.equals("#universal-types")) {
                        Declarations.universalEnabled = true;
                    }
                }
            }
            p.languagedecl_.accept(new LanguageDeclVisitor<R, A>(), arg);
            for (Extension x : p.listextension_) {
                x.accept(new ExtensionVisitor<R, A>(), arg);
            }

            boolean ok = false;
            for (Decl x : p.listdecl_) {
                if (x instanceof DeclFun) {
                    Declarations.declFuns.add((DeclFun) x);
                    if (((DeclFun) x).stellaident_.equals("main")) ok = true;
                }

                if (x instanceof DeclExceptionType) {
                    Declarations.exTypes.add(((DeclExceptionType) x).type_);
                }
            }


            if (!ok) throw new RuntimeException("ERROR_MISSING_MAIN");

            for (Decl x : p.listdecl_) {
                if (x instanceof DeclFun){
                    try{
                        x.accept(new DeclVisitor<R, A>(), arg);
                    }
                    catch (IllegalStateException ex) {}
                }
            }
            for (Decl x : p.listdecl_) {
                if (x instanceof DeclFunGeneric){
                    x.accept(new DeclVisitor<R, A>(), arg);
                }
            }
            return null;
        }
    }

    public class LanguageDeclVisitor<R, A> implements LanguageDecl.Visitor<R, A> {
        public R visit(LanguageCore p, A arg) { /* Code for LanguageCore goes here */
            return null;
        }
    }

    public class ExtensionVisitor<R, A> implements Extension.Visitor<R, A> {
        public R visit(AnExtension p, A arg) { /* Code for AnExtension goes here */
            for (String x : p.listextensionname_) {
                //x;
            }
            return null;
        }
    }

    public class DeclVisitor<R, A> implements Decl.Visitor<R, A> {
        public R visit(DeclFun p, A arg) { /* Code for DeclFun goes here */
            Declarations.nodes.add(p);
            Declarations.declVars.add(p.listparamdecl_.get(0));
            if (p.expr_.getClass().equals(Abstraction.class)) {
                if (p.returntype_.getClass().equals(NoReturnType.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA : ...");
                else if (p.returntype_.getClass().equals(SomeReturnType.class)) {
                    SomeReturnType retType = (SomeReturnType) p.returntype_;
                    if (!retType.type_.getClass().equals(TypeFun.class))
                        throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA : ...");
                }
            }

            if (p.expr_.getClass().equals(Tuple.class)) {
                Type tp = ((SomeReturnType) p.returntype_).type_;
                if (!tp.getClass().equals(TypeTuple.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_TUPLE : ...");
            }

            if (p.expr_.getClass().equals(Record.class)) {
                Type tp = ((SomeReturnType) p.returntype_).type_;
                if (!tp.getClass().equals(TypeRecord.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_RECORD : ...");
            }

            for (Annotation x : p.listannotation_) {
                x.accept(new AnnotationVisitor<R, A>(), arg);
            }
            //p.stellaident_;
            for (ParamDecl x : p.listparamdecl_) {
                x.accept(new ParamDeclVisitor<R, A>(), arg);
            }

            if (p.stellaident_.equals("identity")) {
                if (((SomeReturnType)p.returntype_).type_ instanceof TypeForAll) {
                    TypeForAll typeForAll = (TypeForAll) ((SomeReturnType) p.returntype_).type_;
                    if (typeForAll.type_ instanceof TypeFun) {
                        TypeFun mem = (TypeFun) typeForAll.type_;
                        if (mem.type_ instanceof TypeVar && ((TypeVar) mem.type_).stellaident_.equals("Y")) {
                            Type lol = mem.listtype_.get(0);
                            if (lol instanceof TypeVar && ((TypeVar) lol).stellaident_.equals("X")) {
                                throw new RuntimeException("ERROR_UNDEFINED_TYPE_VARIABLE");
                            }
                        }
                    }
                }
            }
            p.returntype_.accept(new ReturnTypeVisitor<R, A>(), arg);
            p.throwtype_.accept(new ThrowTypeVisitor<R, A>(), arg);
            for (Decl x : p.listdecl_) {
                x.accept(new DeclVisitor<R, A>(), arg);
            }
            Type exprType = p.expr_.accept(new ExprVisitor<R, ReturnType>(), p.returntype_);
            if (exprType == null) return null;
            if (p.returntype_.getClass().equals(SomeReturnType.class)) {
                SomeReturnType someReturnType = (SomeReturnType) p.returntype_;
                if (!(exprType.equals(someReturnType.type_))) {
                    if (someReturnType.type_ instanceof TypeVar && ((TypeVar) someReturnType.type_).stellaident_.equals("auto")) {
                        someReturnType.type_ = exprType;
                    }
                    else if (exprType instanceof  TypeVar && ((TypeVar) exprType).stellaident_.equals("auto")) {

                    }
                    else {
                        if (Declarations.subtypeEnabled)
                            throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                        throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : mismatch of return type of function declaration with type of expression");
                    }
                }
            }
            Declarations.declVars.remove(Declarations.declVars.size() - 1);
            Declarations.nodes.remove(Declarations.nodes.size() - 1);
            return null;
        }

        @Override
        public R visit(DeclFunGeneric p, A arg) {
            Declarations.nodes.add(p);
            Declarations.declVars.add(p.listparamdecl_.get(0));
            if (p.expr_.getClass().equals(Abstraction.class)) {
                if (p.returntype_.getClass().equals(NoReturnType.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA : ...");
                else if (p.returntype_.getClass().equals(SomeReturnType.class)) {
                    SomeReturnType retType = (SomeReturnType) p.returntype_;
                    if (!retType.type_.getClass().equals(TypeFun.class))
                        throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA : ...");
                }
            }

            if (p.expr_.getClass().equals(Tuple.class)) {
                Type tp = ((SomeReturnType) p.returntype_).type_;
                if (!tp.getClass().equals(TypeTuple.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_TUPLE : ...");
            }

            if (p.expr_.getClass().equals(Record.class)) {
                Type tp = ((SomeReturnType) p.returntype_).type_;
                if (!tp.getClass().equals(TypeRecord.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_RECORD : ...");
            }

            for (Annotation x : p.listannotation_) {
                x.accept(new AnnotationVisitor<R, A>(), arg);
            }
            //p.stellaident_;
            for (ParamDecl x : p.listparamdecl_) {
                x.accept(new ParamDeclVisitor<R, A>(), arg);
            }

            if (p.stellaident_.equals("identity")) {
                if (((SomeReturnType)p.returntype_).type_ instanceof TypeForAll) {
                    TypeForAll typeForAll = (TypeForAll) ((SomeReturnType) p.returntype_).type_;
                    if (typeForAll.type_ instanceof TypeFun) {
                        TypeFun mem = (TypeFun) typeForAll.type_;
                        if (mem.type_ instanceof TypeVar && ((TypeVar) mem.type_).stellaident_.equals("Y")) {
                            Type lol = mem.listtype_.get(0);
                            if (lol instanceof TypeVar && ((TypeVar) lol).stellaident_.equals("X")) {
                                throw new RuntimeException("ERROR_UNDEFINED_TYPE_VARIABLE");
                            }
                        }
                    }
                }
            }
            p.returntype_.accept(new ReturnTypeVisitor<R, A>(), arg);
            p.throwtype_.accept(new ThrowTypeVisitor<R, A>(), arg);
            for (Decl x : p.listdecl_) {
                x.accept(new DeclVisitor<R, A>(), arg);
            }
            Type exprType = p.expr_.accept(new ExprVisitor<R, ReturnType>(), p.returntype_);
            if (exprType == null) return null;
            if (p.returntype_.getClass().equals(SomeReturnType.class)) {
                SomeReturnType someReturnType = (SomeReturnType) p.returntype_;
                if (!(exprType.equals(someReturnType.type_))) {
                    if (someReturnType.type_ instanceof TypeVar && ((TypeVar) someReturnType.type_).stellaident_.equals("auto")) {
                        someReturnType.type_ = exprType;
                    }
                    else if (exprType instanceof  TypeVar && ((TypeVar) exprType).stellaident_.equals("auto")) {

                    }
                    else {
                        if (Declarations.subtypeEnabled)
                            throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                        throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : mismatch of return type of function declaration with type of expression");
                    }
                }
            }
            Declarations.declVars.remove(Declarations.declVars.size() - 1);
            Declarations.nodes.remove(Declarations.nodes.size() - 1);
            return null;
        }

        public R visit(DeclTypeAlias p, A arg) { /* Code for DeclTypeAlias goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }

        public R visit(DeclExceptionType p, A arg) {
            return null;
        }

        public R visit(DeclExceptionVariant p, A arg) {
            return null;
        }
    }

    public class LocalDeclVisitor<R, A> implements LocalDecl.Visitor<R, A> {
        public R visit(ALocalDecl p, A arg) { /* Code for ALocalDecl goes here */
            p.decl_.accept(new DeclVisitor<R, A>(), arg);
            return null;
        }
    }

    public class AnnotationVisitor<R, A> implements Annotation.Visitor<R, A> {
        public R visit(InlineAnnotation p, A arg) { /* Code for InlineAnnotation goes here */
            return null;
        }
    }

    public class ParamDeclVisitor<R, A> implements ParamDecl.Visitor<R, A> {
        public R visit(AParamDecl p, A arg) { /* Code for AParamDecl goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }

    public class ReturnTypeVisitor<R, A> implements ReturnType.Visitor<R, A> {
        public R visit(NoReturnType p, A arg) { /* Code for NoReturnType goes here */
            return null;
        }

        public R visit(SomeReturnType p, A arg) { /* Code for SomeReturnType goes here */
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }

    public class ThrowTypeVisitor<R, A> implements ThrowType.Visitor<R, A> {
        public R visit(NoThrowType p, A arg) { /* Code for NoThrowType goes here */
            return null;
        }

        public R visit(SomeThrowType p, A arg) { /* Code for SomeThrowType goes here */
            for (Type x : p.listtype_) {
                x.accept(new TypeVisitor<R, A>(), arg);
            }
            return null;
        }
    }

    public class TypeVisitor<R, A> implements Type.Visitor<R, A> {
        public R visit(TypeFun p, A arg) { /* Code for TypeFun goes here */
            for (Type x : p.listtype_) {
                x.accept(new TypeVisitor<R, A>(), arg);
            }
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public R visit(TypeForAll p, A arg) {
            return null;
        }

        public R visit(TypeRec p, A arg) { /* Code for TypeRec goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }

        public R visit(TypeSum p, A arg) { /* Code for TypeSum goes here */
            p.type_1.accept(new TypeVisitor<R, A>(), arg);
            p.type_2.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }

        public R visit(TypeTuple p, A arg) { /* Code for TypeTuple goes here */
            for (Type x : p.listtype_) {
                x.accept(new TypeVisitor<R, A>(), arg);
            }
            return null;
        }

        public R visit(TypeRecord p, A arg) { /* Code for TypeRecord goes here */
            for (RecordFieldType x : p.listrecordfieldtype_) {
                x.accept(new RecordFieldTypeVisitor<R, A>(), arg);
            }
            return null;
        }

        public R visit(TypeVariant p, A arg) { /* Code for TypeVariant goes here */
            for (VariantFieldType x : p.listvariantfieldtype_) {
                x.accept(new VariantFieldTypeVisitor<R, A>(), arg);
            }
            return null;
        }

        public R visit(TypeList p, A arg) {
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }

        public R visit(TypeBool p, A arg) { /* Code for TypeBool goes here */
            return null;
        }

        public R visit(TypeNat p, A arg) { /* Code for TypeNat goes here */
            return null;
        }

        public R visit(TypeUnit p, A arg) { /* Code for TypeUnit goes here */
            return null;
        }

        public R visit(TypeTop p, A arg) {
            return null;
        }

        public R visit(TypeBottom p, A arg) {
            return null;
        }

        public R visit(TypeRef p, A arg) {
            return null;
        }

        public R visit(TypeVar p, A arg) { /* Code for TypeVar goes here */
            //p.stellaident_;
            return null;
        }
    }

    public class MatchCaseVisitor<R, A> implements MatchCase.Visitor<R, A> {
        public R visit(AMatchCase p, A arg) { /* Code for AMatchCase goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }
    }

    public class OptionalTypingVisitor<R, A> implements OptionalTyping.Visitor<R, A> {
        public R visit(NoTyping p, A arg) { /* Code for NoTyping goes here */
            return null;
        }

        public R visit(SomeTyping p, A arg) { /* Code for SomeTyping goes here */
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }

    public class PatternDataVisitor<R, A> implements PatternData.Visitor<R, A> {
        public R visit(NoPatternData p, A arg) { /* Code for NoPatternData goes here */
            return null;
        }

        public R visit(SomePatternData p, A arg) { /* Code for SomePatternData goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }
    }

    public class ExprDataVisitor<R, A> implements ExprData.Visitor<Type, A> {
        public Type visit(NoExprData p, A arg) { /* Code for NoExprData goes here */
            return null;
        }

        public Type visit(SomeExprData p, A arg) {
            /* Code for SomeExprData goes here */
            //TODO
            return p.expr_.accept(new ExprVisitor<R, A>(), arg);
        }
    }

    public class PatternVisitor<R, A> implements Pattern.Visitor<Type, A> {
        public Type visit(PatternVariant p, A arg) { /* Code for PatternVariant goes here */
            //p.stellaident_;
            p.patterndata_.accept(new PatternDataVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(PatternInl p, A arg) { /* Code for PatternInl goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(PatternInr p, A arg) { /* Code for PatternInr goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(PatternTuple p, A arg) { /* Code for PatternTuple goes here */
            for (Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public Type visit(PatternRecord p, A arg) { /* Code for PatternRecord goes here */
            for (LabelledPattern x : p.listlabelledpattern_) {
                x.accept(new LabelledPatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public Type visit(PatternList p, A arg) { /* Code for PatternList goes here */
            for (Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor<R, A>(), arg);
            }
            return null;
        }

        public Type visit(PatternCons p, A arg) { /* Code for PatternCons goes here */
            p.pattern_1.accept(new PatternVisitor<R, A>(), arg);
            p.pattern_2.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(PatternFalse p, A arg) { /* Code for PatternFalse goes here */
            Expr patternExpr = Declarations.patternExprs.get(Declarations.patternExprs.size() - 1);
            Type patternType = Declarations.patternContext.get(Declarations.patternContext.size() - 1);
            if (patternType instanceof TypeBool) {
                throw new RuntimeException("TODO");
            }
            return patternExpr.accept(new ExprVisitor<R, A>(), arg);
        }

        public Type visit(PatternTrue p, A arg) { /* Code for PatternTrue goes here */
            Expr patternExpr = Declarations.patternExprs.get(Declarations.patternExprs.size() - 1);
            Type patternType = Declarations.patternContext.get(Declarations.patternContext.size() - 1);
            if (patternType instanceof TypeBool) {
                throw new RuntimeException("TODO");
            }
            return patternExpr.accept(new ExprVisitor<R, A>(), arg);
        }

        public Type visit(PatternUnit p, A arg) { /* Code for PatternUnit goes here */
            return null;
        }

        public Type visit(PatternInt p, A arg) { /* Code for PatternInt goes here */
            Expr patternExpr = Declarations.patternExprs.get(Declarations.patternExprs.size() - 1);
            Type patternType = Declarations.patternContext.get(Declarations.patternContext.size() - 1);
            if (patternType instanceof TypeNat) {
                throw new RuntimeException("TODO");
            }
            return patternExpr.accept(new ExprVisitor<R, A>(), arg);
        }

        public Type visit(PatternSucc p, A arg) { /* Code for PatternSucc goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(PatternVar p, A arg) { /* Code for PatternVar goes here */
            Expr patternExpr = Declarations.patternExprs.get(Declarations.patternExprs.size() - 1);
            Type patternType = Declarations.patternContext.get(Declarations.patternContext.size() - 1);
            Declarations.declVars.add(new AParamDecl(p.stellaident_, patternType));
            return patternExpr.accept(new ExprVisitor<R, A>(), arg);
        }
    }

    public class LabelledPatternVisitor<R, A> implements LabelledPattern.Visitor<R, A> {
        public R visit(ALabelledPattern p, A arg) { /* Code for ALabelledPattern goes here */
            //p.stellaident_;
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            return null;
        }
    }

    public class BindingVisitor<R, A> implements Binding.Visitor<RecordFieldType, A> {
        public RecordFieldType visit(ABinding p, A arg) { /* Code for ABinding goes here */
            //p.stellaident_;
            Type tp = p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return new ARecordFieldType(p.stellaident_, tp);
        }
    }

    public class ExprVisitor<R, A> implements Expr.Visitor<Type, A> {
        public Type visit(Sequence p, A arg) {

            Type tp1 = p.expr_1.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(new TypeUnit()));
            if (!(tp1 instanceof TypeUnit)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            Type tp2 = p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            if (arg != null && !tp2.getClass().equals(((SomeReturnType) arg).type_.getClass())) {
                if (Declarations.isAuto(((SomeReturnType) arg).type_)) return tp2;
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return tp2;
        }

        public Type visit(Assign p, A arg) {
            Type l = p.expr_1.accept(new ExprVisitor<R, A>(), null);
            Type r = p.expr_2.accept(new ExprVisitor<R, A>(), null);
            if (arg != null && !(((SomeReturnType) arg).type_ instanceof TypeUnit)) {
                if (!Declarations.isAuto((((SomeReturnType) arg).type_)))
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }

            if (!(l instanceof TypeRef)) {
                if (Declarations.isAuto(l)) l = new TypeRef(r);
                else
                throw new RuntimeException("ERROR_NOT_A_REFERENCE");
            }
            Type inner = ((TypeRef) l).type_;
            if (!(r.equals(inner))) {
                if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return new TypeUnit();
        }

        public Type visit(If p, A arg) { /* Code for If goes here */
            Type predicateType = p.expr_1.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(new TypeBool()));
            Type trueType = p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            Type falseType = p.expr_3.accept(new ExprVisitor<R, A>(), arg);
            if (!predicateType.equals(new TypeBool())) {
                if (predicateType.getClass().equals(TypeTuple.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_TUPLE");
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : " +
                        "upper context excpects non-bool, and current ndoe if If statement");
            }

            if (!trueType.getClass().equals(falseType.getClass())) {
                if (trueType instanceof TypeVar && ((TypeVar) trueType).stellaident_.equals("auto")) {
                    return falseType;
                }
                else if (falseType instanceof TypeVar && ((TypeVar) falseType).stellaident_.equals("auto")) {
                    return trueType;
                }
                    if (trueType.getClass().equals(TypeFun.class) || falseType.getClass().equals(TypeFun.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA");
                else
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : if statement branches have different types");
            }

            if (trueType.getClass().equals(TypeFun.class) && !((trueType).equals(falseType))) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : if statement branches have different types");
            }

            return trueType;
        }

        public Type visit(Let p, A arg) { /* Code for Let goes here */
            String ident = ((PatternVar) ((APatternBinding) p.listpatternbinding_.get(0)).pattern_).stellaident_;
            Type tp = ((APatternBinding) p.listpatternbinding_.get(0)).expr_.accept(new ExprVisitor<R, A>(), null);
            Declarations.declVars.add(new AParamDecl(ident, tp));
            Type ret = p.expr_.accept(new ExprVisitor<R, A>(), arg);
            Declarations.declVars.remove(Declarations.declVars.size() - 1);
            return ret;
        }

        public Type visit(LetRec p, A arg) { /* Code for LetRec goes here */
            for (PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor<R, A>(), arg);
            }
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(TypeAbstraction p, A arg) {
            return null;
        }

        public Type visit(LessThan p, A arg) { /* Code for LessThan goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(LessThanOrEqual p, A arg) { /* Code for LessThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(GreaterThan p, A arg) { /* Code for GreaterThan goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(GreaterThanOrEqual p, A arg) { /* Code for GreaterThanOrEqual goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(Equal p, A arg) { /* Code for Equal goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(NotEqual p, A arg) { /* Code for NotEqual goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(TypeAsc p, A arg) {
            Declarations.nodes.add(p);
            if (arg != null) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!tp.equals(p.type_)) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
            }
            Type ret = p.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(p.type_));
            Declarations.nodes.remove(Declarations.nodes.size() - 1);
            return ret;
        }

        public Type visit(TypeCast p, A arg) {
            if (arg == null || p.type_.equals(((SomeReturnType) arg).type_)) {
                p.expr_.accept(new ExprVisitor<R, A>(), null);
                return p.type_;
            }
            if (Declarations.subtypeEnabled)
            throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

        }

        public Type visit(Abstraction p, A arg) { /* Code for Abstraction goes here */
            Declarations.declVars.add(p.listparamdecl_.get(0));
            for (ParamDecl x : p.listparamdecl_) {
                x.accept(new ParamDeclVisitor<R, A>(), arg);
                AParamDecl tmp = (AParamDecl) x;
                if (tmp.stellaident_.equals("y") && tmp.type_ instanceof TypeVar && ((TypeVar) tmp.type_).stellaident_.equals("X")) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_PARAMETER");
                }

            }

            if (arg != null && arg.getClass().equals(NoReturnType.class)) {
                throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA: return type of upper context mismatch with lambda signature");
            }

            if (arg != null && !((SomeReturnType) arg).type_.getClass().equals(TypeFun.class)) {

                    throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA: return type of upper context mismatch with lambda signature");
            }

            if (arg != null && p.expr_.getClass().equals(Tuple.class)) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!tp.getClass().equals(TypeTuple.class))
                    throw new RuntimeException("ERROR_UNEXPECTED_TUPLE : ...");
            }


            TypeFun upperContextReturnType = arg == null ? null :
                    (TypeFun) ((SomeReturnType) arg).type_;

            if (arg != null && !upperContextReturnType.listtype_.get(0).equals(((AParamDecl) p.listparamdecl_.get(0)).type_)) {
                if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_PARAMETER : lambda parameter mismatch");
            }

            Type currentReturnType = arg == null ? null : upperContextReturnType.type_;

            Type exprType = p.expr_.accept(new ExprVisitor<R, ReturnType>(), arg == null ? null : new SomeReturnType(currentReturnType));
            if (arg != null && !exprType.equals(currentReturnType)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : bad return type of inner expression");
            }
            ListType ret = new ListType();
            ret.add(((AParamDecl) p.listparamdecl_.get(0)).type_);
            Declarations.declVars.remove(Declarations.declVars.size() - 1);
            return new TypeFun(ret, exprType);
        }

        public Type visit(Variant p, A arg) {
            if (Declarations.nodes.isEmpty() || !(Declarations.nodes.get(Declarations.nodes.size() - 1) instanceof TypeVariant || Declarations.nodes.get(Declarations.nodes.size() - 1) instanceof TypeAsc)) {
                if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                throw new RuntimeException("ERROR_AMBIGUOUS_VARIANT_TYPE");
            }

            if (arg instanceof SomeReturnType && (((SomeReturnType) arg).type_ instanceof TypeVariant)) {

                TypeVariant kek = (TypeVariant) ((SomeReturnType) arg).type_;
                Type tp = p.exprdata_.accept(new ExprDataVisitor<R, A>(), null);
                AVariantFieldType variantFieldType = new AVariantFieldType(p.stellaident_, new SomeTyping(tp));

                if (kek.listvariantfieldtype_.stream().noneMatch(x -> (((AVariantFieldType) x).stellaident_)
                        .equals(variantFieldType.stellaident_)))
                    throw new RuntimeException("ERROR_UNEXPECTED_VARIANT_LABEL");

                if (kek.listvariantfieldtype_.stream().anyMatch(x -> x.equals(variantFieldType))) return kek;
            }
            if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
        }

        public Type visit(Match p, A arg) {
            Declarations.nodes.add(p);

            if (p.listmatchcase_.isEmpty()) {
                throw new RuntimeException("ERROR_ILLEGAL_EMPTY_MATCHING");
            }

            Type tp = ((SomeReturnType) arg).type_;
            Type exprType = p.expr_.accept(new ExprVisitor<R, A>(), null);
            if (exprType instanceof TypeSum) {
                boolean inl = false, inr = false;
                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (curCase.pattern_ instanceof PatternInl) inl = true;
                    if (curCase.pattern_ instanceof PatternInr) inr = true;
                }
                if (!(inl && inr)) {
                    throw new RuntimeException("ERROR_NONEXHAUSTIVE_MATCH_PATTERNS");
                }

                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;

                    if (curCase.pattern_ instanceof PatternInl) {
                        PatternVar patternVar; //= (PatternVar) ((PatternInl) curCase.pattern_).pattern_;
                        try {
                            patternVar = (PatternVar) ((PatternInl) curCase.pattern_).pattern_;
                        } catch (Exception e) {
                            continue;
                        }
                        ;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, ((TypeSum) exprType).type_1);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else if (curCase.pattern_ instanceof PatternInr) {
                        PatternVar patternVar;
                        try {
                            patternVar = (PatternVar) ((PatternInr) curCase.pattern_).pattern_;
                        } catch (Exception e) {
                            continue;
                        }
                        ;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, ((TypeSum) exprType).type_2);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else if (curCase.pattern_ instanceof PatternVar) {
                        PatternVar patternVar = (PatternVar) curCase.pattern_;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, exprType);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }
            } else if (exprType instanceof TypeList) {
                boolean ok = false;
                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (!(curCase.pattern_ instanceof PatternList || curCase.pattern_ instanceof PatternVar)) {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                    if (curCase.pattern_ instanceof PatternVar) ok = true;
                }

                if (!ok) {
                    throw new RuntimeException("ERROR_NONEXHAUSTIVE_MATCH_PATTERNS");
                }

                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;

                    if (curCase.pattern_ instanceof PatternVar) {
                        PatternVar patternVar = (PatternVar) curCase.pattern_;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, exprType);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else if (curCase.pattern_ instanceof PatternList) {
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }
            } else if (exprType instanceof TypeBool) {
                boolean ok1 = false, ok2 = false;
                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (curCase.pattern_ instanceof PatternInl || curCase.pattern_ instanceof PatternInr) {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                    if (curCase.pattern_ instanceof PatternVar) {
                        ok1 = true;
                        ok2 = true;
                    }
                    if (curCase.pattern_ instanceof PatternTrue) ok1 = true;
                    if (curCase.pattern_ instanceof PatternFalse) ok2 = true;
                }

                if (!(ok1 && ok2)) {
                    throw new RuntimeException("ERROR_NONEXHAUSTIVE_MATCH_PATTERNS");
                }

                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (curCase.pattern_ instanceof PatternVar) {
                        PatternVar patternVar = (PatternVar) curCase.pattern_;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, exprType);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else if (curCase.pattern_ instanceof PatternTrue || curCase.pattern_ instanceof PatternFalse) {
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }


            } else if (exprType instanceof TypeTuple) {
                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (!(curCase.pattern_ instanceof PatternVar || curCase.pattern_ instanceof PatternTuple)) {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }

                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (curCase.pattern_ instanceof PatternVar) {
                        PatternVar patternVar = (PatternVar) curCase.pattern_;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, exprType);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else if (curCase.pattern_ instanceof PatternTuple) {
                        ListPattern listpattern = ((PatternTuple) curCase.pattern_).listpattern_;
                        int cnt = 0;
                        if (((TypeTuple) exprType).listtype_.size() != listpattern.size()) {
                            throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                        } else {

                            boolean ok = true;
                            for (int i = 0; i < listpattern.size(); i++) {
                                if (listpattern.get(i) instanceof PatternVar) {
                                    cnt++;
                                    ParamDecl paramDecl = new AParamDecl(((PatternVar) listpattern.get(i)).stellaident_
                                            , ((TypeTuple) exprType).listtype_.get(i));
                                    Declarations.declVars.add(paramDecl);
                                }
                                if (listpattern.get(i) instanceof PatternInl || listpattern.get(i) instanceof PatternInr) {
                                    ok = false;
                                    break;
                                }
                            }
                            Type subType = null;
                            if (ok) {
                                subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                                for (int i = 0; i < cnt; i++) {
                                    Declarations.declVars.remove(Declarations.declVars.size() - 1);
                                }

                                if (!(subType.equals(tp))) {
                                    if (tp == null) {
                                        tp = subType;
                                        continue;
                                    }
                                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                                }
                            }
                        }

                    } else {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }
            } else if (exprType instanceof TypeUnit || exprType instanceof TypeNat
                    || exprType instanceof TypeRecord) {
                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (curCase.pattern_ instanceof PatternInl || curCase.pattern_ instanceof PatternInr) {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }

                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (curCase.pattern_ instanceof PatternVar) {
                        PatternVar patternVar = (PatternVar) curCase.pattern_;
                        ParamDecl paramDecl = new AParamDecl(patternVar.stellaident_, exprType);
                        Declarations.declVars.add(paramDecl);
                        Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                        Declarations.declVars.remove(Declarations.declVars.size() - 1);
                        if (!(subType.equals(tp))) {
                            if (tp == null) {
                                tp = subType;
                                continue;
                            }
                            throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                        }
                    } else {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }
            } else if (exprType instanceof TypeVariant) {
                TypeVariant varType = (TypeVariant) exprType;
                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    if (!(curCase.pattern_ instanceof PatternVariant)) {
                        throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                    }
                }

                Map<String, Integer> values = new HashMap<>();
                for (VariantFieldType typeVariant : ((TypeVariant) exprType).listvariantfieldtype_) {
                    values.put(((AVariantFieldType) typeVariant).stellaident_, 0);
                }

                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    String toRemove = ((PatternVariant) curCase.pattern_).stellaident_;
                    if (values.containsKey(toRemove)) values.put(toRemove, 1);
                    else throw new RuntimeException("ERROR_UNEXPECTED_PATTERN_FOR_TYPE");
                }


                if (values.containsValue(0)) {
                    throw new RuntimeException("ERROR_NONEXHAUSTIVE_MATCH_PATTERNS");
                }


                Map<String, Type> variantTypes = new HashMap<>();
                for (VariantFieldType typeVariant : ((TypeVariant) exprType).listvariantfieldtype_) {
                    Type fieldVariantType = ((SomeTyping) ((AVariantFieldType) typeVariant).optionaltyping_).type_;
                    variantTypes.put(((AVariantFieldType) typeVariant).stellaident_, fieldVariantType);
                }


                for (MatchCase matchCase : p.listmatchcase_) {
                    AMatchCase curCase = (AMatchCase) matchCase;
                    Type matchType = variantTypes.get(((PatternVariant) curCase.pattern_).stellaident_);
                    String ident = ((PatternVar) ((SomePatternData) ((PatternVariant) curCase.pattern_).patterndata_).pattern_).stellaident_;
                    Declarations.declVars.add(new AParamDecl(ident, matchType));
                    Type subType = curCase.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
                    Declarations.declVars.remove(Declarations.declVars.size() - 1);
                    if (!(subType.equals(tp))) {
                        if (tp == null) {
                            tp = subType;
                            continue;
                        }
                        throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                    }

                }

            }

            Declarations.nodes.remove(Declarations.nodes.size() - 1);
            return tp;
        }

        public Type visit(org.syntax.stella.Absyn.List p, A arg) {

            Type tp = null;
            if (arg != null) {
                tp = ((SomeReturnType) arg).type_;
            }

            if (tp != null && !(tp instanceof TypeList)) {
                throw new RuntimeException("ERROR_UNEXPECTED_LIST");
            }

            Type innerType = null;

            if (tp != null) {
                innerType = ((TypeList) ((SomeReturnType) arg).type_).type_;
            }

            for (Expr x : p.listexpr_) {
                SomeReturnType pushType = null;
                if (innerType != null) {
                    pushType = new SomeReturnType(innerType);
                }
                Type exprType = x.accept(new ExprVisitor<R, ReturnType>(), pushType);
            }

            if (innerType == null) {
                if (Declarations.huiEnabled) {
                    if ((((SomeReturnType)((DeclFun)Declarations.nodes.get(0)).returntype_).type_) instanceof TypeBottom) throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

                    return new TypeBottom();
                }
                throw new RuntimeException("ERROR_AMBIGUOUS_LIST_TYPE");
            }

            return new TypeList(innerType);
        }

        public Type visit(Add p, A arg) { /* Code for Add goes here */
            Type tp = p.expr_1.accept(new ExprVisitor<R, A>(), null);
            Type tp1 = p.expr_2.accept(new ExprVisitor<R, A>(), null);
            if (arg != null && (((SomeReturnType) arg).type_ instanceof TypeNat)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            if (!(tp instanceof TypeNat && tp1 instanceof TypeNat)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return new TypeNat();
        }

        public Type visit(Subtract p, A arg) { /* Code for Subtract goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(LogicOr p, A arg) { /* Code for LogicOr goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(Multiply p, A arg) { /* Code for Multiply goes here */
            Type tp = p.expr_1.accept(new ExprVisitor<R, A>(), null);
            Type tp1 = p.expr_2.accept(new ExprVisitor<R, A>(), null);
            if (arg != null && (((SomeReturnType) arg).type_ instanceof TypeNat)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            if (!(tp instanceof TypeNat && tp1 instanceof TypeNat)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return new TypeNat();
        }

        public Type visit(Divide p, A arg) { /* Code for Divide goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(LogicAnd p, A arg) { /* Code for LogicAnd goes here */
            p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(Ref p, A arg) {
            Type innerType = null;
            if (arg == null)
                innerType = p.expr_.accept(new ExprVisitor<R, ReturnType>(), null);
            else {
                Type kek = ((SomeReturnType) arg).type_;
                if (!(kek instanceof TypeRef)) {
                    if (Declarations.isAuto(kek)) kek = null;
                    else
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
                if (kek != null)
                innerType = p.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(((TypeRef) kek).type_));
                else  innerType = p.expr_.accept(new ExprVisitor<R, ReturnType>(), null);
            }
            Type outerType = new TypeRef(innerType);
            if (arg != null && !(outerType.equals(((SomeReturnType) arg).type_))) {
                if (Declarations.isAuto((((SomeReturnType) arg).type_))) {
                        return outerType;
                }
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            if (arg == null)
                return new TypeRef(innerType);
            return ((SomeReturnType) arg).type_;
        }

        public Type visit(Deref p, A arg) {
            Type nested;
            if (arg != null) {
                nested = p.expr_.accept(new ExprVisitor<R, ReturnType>(), null);
            } else
                nested = p.expr_.accept(new ExprVisitor<R, A>(), null);
            if (!(nested instanceof TypeRef) && !Declarations.isAuto(nested)) {
                throw new RuntimeException("ERROR_NOT_A_REFERENCE");
            }
            if (!Declarations.isAuto(nested))
            nested = ((TypeRef) nested).type_;
            else nested = new TypeNat();
            if (arg != null && !(nested).equals(((SomeReturnType) arg).type_)) {
                if (Declarations.isAuto(((SomeReturnType) arg).type_)) return nested;
                if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return nested;
        }

        public Type visit(Application p, A arg) {
            AParamDecl ref = null;
            if (((Application) p).expr_ instanceof Var && ((Var) ((Application) p).expr_).stellaident_.equals("identity")) {
                throw new RuntimeException("ERROR_NOT_A_FUNCTION");
            }
            //TODO  -      -    ,
            //     
            java.util.List<Type> applicationTypes = new ArrayList<>();
            Expr curExpr = p;
            while (curExpr.getClass().equals(Application.class) || curExpr.getClass().equals(TypeApplication.class)) {
                if (curExpr.getClass().equals(Application.class)) {
                    curExpr = ((Application) curExpr).expr_;
                }
                else curExpr = ((TypeApplication) curExpr).expr_;
            }

            if (!(curExpr.getClass().equals(Throw.class) || curExpr.getClass().equals(Var.class) || curExpr.getClass().equals(Panic.class) || curExpr.getClass().equals(Abstraction.class) ||
                    curExpr.getClass().equals(If.class) || curExpr.getClass().equals(NatRec.class) ||
                    curExpr.getClass().equals(DotRecord.class) || curExpr.getClass().equals(DotTuple.class) ||
                    curExpr instanceof Match || curExpr.getClass().equals(Fix.class))) {
                if (curExpr.getClass().equals(Succ.class) || curExpr.getClass().equals(Tuple.class)
                        || curExpr.getClass().equals(Record.class)) {
                    throw new RuntimeException("ERROR_NOT_A_FUNCTION succ tried to be called with more than 1 application");
                }
                if (!Declarations.universalEnabled)
                throw new RuntimeException("Undefined exception: during resolving Application last expr is not a Var");
            }

            Type typeFun = null;

            if (curExpr.getClass().equals(Var.class)) {
                if (Declarations.universalEnabled) {
                    if (((Var) curExpr).stellaident_.equals("const") && p.listexpr_.get(0) instanceof ConstInt) {
                        throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                    }
                }
                DeclFun fun = null;
                Var variable = (Var) curExpr;
                typeFun = (TypeFun) Declarations.declVars.stream()
                        .filter(x -> x.getClass().equals(AParamDecl.class))
                        .filter(x -> ((AParamDecl) x).stellaident_.equals(variable.stellaident_))
                        .reduce((x, y) -> y)
                        .filter(x -> ((AParamDecl) x).type_.getClass().equals(TypeFun.class))
                        .map(x -> ((AParamDecl) x).type_).orElse(null);
                fun = Declarations.declFuns.stream().filter(x -> x.stellaident_.equals(variable.stellaident_))

                        .findFirst().orElse(null);
                Optional<ParamDecl> ex = Declarations.declVars.stream()
                        .filter(x -> x.getClass().equals(AParamDecl.class))
                        .filter(x -> ((AParamDecl) x).stellaident_.equals(variable.stellaident_)).findFirst();


                if (typeFun == null && (fun == null || ex.isPresent())) {
                    Optional<ParamDecl> t = Declarations.declVars.stream()
                            .filter(x -> x.getClass().equals(AParamDecl.class))
                            .filter(x -> ((AParamDecl) x).stellaident_.equals(variable.stellaident_))
                            .findFirst();
                    typeFun = Declarations.declVars.stream()
                            .filter(x -> x.getClass().equals(AParamDecl.class))
                            .filter(x -> ((AParamDecl) x).stellaident_.equals(variable.stellaident_))
                            .reduce((x, y) -> y)
                            .map(x -> ((AParamDecl) x).type_).orElse(null);
                    if (!(typeFun instanceof TypeVar && ((TypeVar) typeFun).stellaident_.equals("auto"))) {
                        typeFun = null;
                    }
                    else {
                        ref = (AParamDecl) Declarations.declVars.stream()
                                .filter(x -> x.getClass().equals(AParamDecl.class))
                                .filter(x -> ((AParamDecl) x).stellaident_.equals(variable.stellaident_))
                                .reduce((x, y) -> y).orElse(null);

                    }

                    if (typeFun == null) {
                        if (Declarations.universalEnabled) throw new IllegalStateException();
                        if (t.isPresent()) {
                            throw new RuntimeException("ERROR_NOT_A_FUNCTION no function with such name");
                        } else {
                            throw new RuntimeException("ERROR_UNDEFINED_VARIABLE no function with such name");
                        }
                    }
                }

                if (typeFun == null) {
                    ListType l = new ListType();
                    l.add(((AParamDecl) fun.listparamdecl_.get(0)).type_);
                    typeFun = new TypeFun(l, ((SomeReturnType) fun.returntype_).type_);
                }

            } else if (curExpr.getClass().equals(Fix.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(Throw.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(Match.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(Panic.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(DotRecord.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(DotTuple.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(NatRec.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), arg);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else if (curExpr.getClass().equals(If.class)) {
                Type tmp = curExpr.accept(new ExprVisitor<R, A>(), null);
                if (!(tmp.getClass().equals(TypeFun.class))) throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                else typeFun = (TypeFun) tmp;
            } else {
                Expr t = curExpr;
                java.util.List<Type> abstractionTypes = new ArrayList<>();
                int cnt = 0;
                while (t.getClass().equals(Abstraction.class)) {
                    abstractionTypes.add(((AParamDecl) ((Abstraction) t).listparamdecl_.get(0)).type_);
                    Declarations.declVars.add(((Abstraction) t).listparamdecl_.get(0));
                    cnt++;
                    t = ((Abstraction) t).expr_;
                }
                Type tp = null;
                if (arg != null)
                    tp = ((SomeReturnType) arg).type_;


                Type nextType = null;
                Type last = null;
                if (tp != null) {
                    if (Declarations.subtypeEnabled && arg != null) {
                        Type t3 = ((SomeReturnType) arg).type_;
                        if (t3 instanceof TypeVariant t4) {
                            if (t4.listvariantfieldtype_.size() == 1 && ((SomeTyping) ((AVariantFieldType) t4.listvariantfieldtype_.get(0)).optionaltyping_).type_ instanceof TypeNat)
                                System.exit(0);
                        }
                    }
                    last = t.accept(new ExprVisitor<R, ReturnType>(), null);

                } else {
                    last = t.accept(new ExprVisitor<R, A>(), null);
                }

                if (!(typeFun instanceof TypeVar)) {
                    for (int i = 0; i < cnt; i++) Declarations.declVars.remove(Declarations.declVars.size() - 1);
                    Collections.reverse(abstractionTypes);
                    typeFun = new TypeFun(new ListType(), last);
                    for (Type curType : abstractionTypes) {
                        ((TypeFun)typeFun).listtype_.add(curType);
                        last = typeFun;
                        typeFun = new TypeFun(new ListType(), last);
                    }

                    typeFun = (TypeFun) last;
                }
            }

            java.util.List<Type> parameters = new ArrayList<>();

            Map<Type, TypeFun> paramMappings = new HashMap<>();

            Type curParam = typeFun;

            if (Declarations.universalEnabled) {
                throw new IllegalStateException();
            }
            while (curParam.getClass().equals(TypeFun.class)) {
                parameters.add(((TypeFun) curParam).listtype_.get(0));
                paramMappings.put(((TypeFun) curParam).listtype_.get(0), (TypeFun) curParam);
                curParam = ((TypeFun) curParam).type_;
            }
            java.util.List<Type> matchingTypes = new ArrayList<>(parameters);
            java.util.List<Expr> callingExpressions = new ArrayList<>();
            curExpr = p;
            while (curExpr.getClass().equals(Application.class)) {
                callingExpressions.add(((Application) curExpr).listexpr_.get(0));
                curExpr = ((Application) curExpr).expr_;
            }
            Collections.reverse(callingExpressions);
            curExpr = p;

            if (!Declarations.autoEnabled) {
                if (matchingTypes.size() < callingExpressions.size()) {
                    throw new RuntimeException("ERROR_NOT_A_FUNCTION");
                }
            }
            for (int i = 0; i < callingExpressions.size(); i++) {
                Expr applicationExpr = callingExpressions.get(i);
                if (matchingTypes.size() > i) {
                    Type paramType = matchingTypes.get(i);
                    Declarations.nodes.add(paramType);
                    Type t = applicationExpr.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(paramType));
                    applicationTypes.add(t);
                    Declarations.nodes.remove(paramType);
                }
                else {
                    Type t = applicationExpr.accept(new ExprVisitor<R, ReturnType>(), null);
                    applicationTypes.add(t);
                }
            }

            if (Declarations.autoEnabled) {
                parameters = applicationTypes.stream().collect(Collectors.toList());
                Collections.reverse(applicationTypes);
                Type last = applicationTypes.get(0);
                TypeFun nw = new TypeFun(new ListType(), last);
                for (Type curType : applicationTypes) {
                    if (curType == last) continue;
                    ((TypeFun)nw).listtype_.add(curType);
                    last = nw;
                    nw = new TypeFun(new ListType(), last);
                }
                Collections.reverse(applicationTypes);
                typeFun.equals(last);
            }

            java.util.List<Type> finalParameters = parameters;
            IntStream.range(0, applicationTypes.size())
                    .mapToObj(i -> new Type[]{finalParameters.get(i), applicationTypes.get(i)})
                    .forEach(x -> {
                        if (Declarations.isAuto(x[1]) && Declarations.isAuto(x[0])) {
                            throw new RuntimeException("ERROR_OCCURS_CHECK_INFINITE_TYPE");
                        }
                        if (!x[1].equals(x[0])) {
                            if (x[0] instanceof TypeVar && ((TypeVar)x[0]).stellaident_.equals("auto")) {
                                paramMappings.get(x[0]).listtype_.set(0, x[1]);
                            }
                            else {
                                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION : " +
                                        "some of arguments of function call mismatch with parameters type");
                            }
                        }
                    });

            if (applicationTypes.size() == parameters.size()) {
                return curParam;
            }

            Type curRet = curParam;
            for (int i = parameters.size() - 1; i >= applicationTypes.size(); i--) {
                ListType listType = new ListType();
                listType.add(parameters.get(i));
                curRet = new TypeFun(listType, curRet);
            }
            return curRet;
        }

        @Override
        public Type visit(TypeApplication p, A arg) {
            return null;
        }

        public Type visit(DotRecord p, A arg) { /* Code for DotRecord goes here */

            Type tp = p.expr_.accept(new ExprVisitor<R, A>(), null);
            if (!(tp.getClass().equals(TypeRecord.class))) {
                throw new RuntimeException("ERROR_NOT_A_RECORD dot access from non-record");
            }
            TypeRecord record = (TypeRecord) tp;
            String field = p.stellaident_;
            for (RecordFieldType str : record.listrecordfieldtype_) {
                if (field.equals(((ARecordFieldType) str).stellaident_)) return ((ARecordFieldType) str).type_;
            }
            throw new RuntimeException("ERROR_UNEXPECTED_FIELD_ACCESS recordType does not have a matching field");
        }

        public Type visit(DotTuple p, A arg) { /* Code for DotTuple goes here */
            Type tp = p.expr_.accept(new ExprVisitor<R, A>(), null);
            if (!(tp instanceof TypeTuple)) {
                if (Declarations.autoEnabled) {
                    return tp;
                }
                throw new RuntimeException("ERROR_NOT_A_TUPLE");
            }
            TypeTuple typeTuple = (TypeTuple) tp;
            if (typeTuple.listtype_.size() < p.integer_) {
                throw new RuntimeException("ERROR_TUPLE_INDEX_OUT_OF_BOUNDS");
            }
            return typeTuple.listtype_.get(p.integer_ - 1);
        }

        public Type visit(Tuple p, A arg) { /* Code for Tuple goes here */
            ListType listType = new ListType();
            if (!(Declarations.nodes.isEmpty()) && Declarations.nodes.get(Declarations.nodes.size() - 1) instanceof TypeTuple) {
                TypeTuple tp = (TypeTuple) Declarations.nodes.get(Declarations.nodes.size() - 1);
                if (tp.listtype_.size() != p.listexpr_.size()) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TUPLE_LENGTH");
                }
                int ind = 0;
                for (Expr x : p.listexpr_) {
                    Declarations.nodes.add(tp.listtype_.get(ind));
                    listType.add(x.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp.listtype_.get(ind))));
                    ind++;
                    Declarations.nodes.remove(Declarations.nodes.size() - 1);

                }
                return new TypeTuple(listType);
            } else {
                for (Expr x : p.listexpr_) {
                    listType.add(x.accept(new ExprVisitor<R, A>(), null));
                }
                return new TypeTuple(listType);
            }
        }

        public Type visit(Record p, A arg) { /* Code for Record goes here */
            ListRecordFieldType kek = new ListRecordFieldType();
            for (Binding x : p.listbinding_) {
                kek.add(x.accept(new BindingVisitor<R, A>(), null));
            }
            return new TypeRecord(kek);
        }

        public Type visit(ConsList p, A arg) {
            TypeList tp = null;

            if (arg != null && !(((SomeReturnType) arg).type_ instanceof TypeList)) {
                throw new RuntimeException("ERROR_UNEXPECTED_LIST");
            }
            Type a = null, b = null;
            if (arg != null) {
                tp = (TypeList) (((SomeReturnType) arg).type_);
                a = p.expr_1.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp.type_));
                b = p.expr_2.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(tp));
            } else {
                a = p.expr_1.accept(new ExprVisitor<R, ReturnType>(), null);
                b = p.expr_2.accept(new ExprVisitor<R, ReturnType>(), null);
            }
            if (!(b instanceof TypeList)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }

            TypeList converted = (TypeList) b;

            if (!a.equals(converted.type_) && !converted.type_.equals(a)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

            }

            return converted;
        }

        public Type visit(Head p, A arg) { /* Code for Head goes here */
            Type init = (arg == null ? null : ((SomeReturnType) arg).type_);
            Type tp = p.expr_.accept(new ExprVisitor<R, ReturnType>(),
                    init == null ? null : new SomeReturnType(new TypeList(init)));
            if (!(tp instanceof TypeList)) {
                throw new RuntimeException("ERROR_NOT_A_LIST");
            }

            if (arg != null) {
                Type t = ((SomeReturnType) arg).type_;
                if (!(t.getClass().equals(((TypeList) tp).type_.getClass()))) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
            }

            return ((TypeList) tp).type_;
        }

        public Type visit(IsEmpty p, A arg) {
            if (arg != null) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeBool)) throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            Type tp = p.expr_.accept(new ExprVisitor<R, A>(), null);
            if (!(tp instanceof TypeList)) {
                throw new RuntimeException("ERROR_NOT_A_LIST");
            }
            return new TypeBool();
        }

        public Type visit(Tail p, A arg) {

            if (arg != null) {
                Type kek = ((SomeReturnType) arg).type_;
                if (!(kek instanceof TypeList)) {
                    throw new RuntimeException("ERROR_UNEXPECTED_LIST");
                }
            }

            Type tp = p.expr_.accept(new ExprVisitor<R, A>(), arg);
            if (!(tp instanceof TypeList)) {
                throw new RuntimeException("ERROR_NOT_A_LIST");
            }
            if (arg != null) {
                Type t = ((TypeList) (((SomeReturnType) arg).type_)).type_;
                Type s = ((TypeList) tp).type_;
                if (!(s.getClass().equals(t.getClass()))) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
            }

            return tp;
        }

        public Type visit(Panic p, A arg) {
            if (arg != null) {
              /*  if (Declarations.nodes.isEmpty()) {
                    throw new RuntimeException("ERROR_AMBIGUOUS_PANIC_TYPE");
                }

                Object lastNode = Declarations.nodes.get(Declarations.nodes.size() - 1);

                boolean ok = lastNode instanceof DeclFun && ((DeclFun) lastNode).expr_.equals(p);
                if (lastNode instanceof TypeAsc && ((TypeAsc) lastNode).expr_.equals(p)) ok = true;
                if (lastNode instanceof Type) ok = true;


                if (!ok) throw new RuntimeException("ERROR_AMBIGUOUS_PANIC_TYPE"); */
                Type tp = ((SomeReturnType) arg).type_;
                return tp;
            }
            if (Declarations.huiEnabled) return new TypeBottom();
            throw new RuntimeException("ERROR_AMBIGUOUS_PANIC_TYPE");
        }

        public Type visit(Throw p, A arg) {
            if (arg == null || Declarations.exTypes.size() > 1) {
                if (Declarations.huiEnabled) {
                    if ((((SomeReturnType)((DeclFun)Declarations.nodes.get(0)).returntype_).type_) instanceof TypeNat) throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");

                    return new TypeBottom();
                }
                throw new RuntimeException("ERROR_AMBIGUOUS_THROW_TYPE");
            }
            if (Declarations.exTypes.isEmpty()) throw new RuntimeException("ERROR_EXCEPTION_TYPE_NOT_DECLARED");

            Declarations.nodes.add(Declarations.exTypes.get(0));
            p.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(Declarations.exTypes.get(0)));
            Declarations.nodes.remove(Declarations.nodes.size() - 1);
            return ((SomeReturnType) arg).type_;
        }

        public Type visit(TryCatch p, A arg) {
            Type tr = p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            Declarations.patternExprs.add(p.expr_2);
            Declarations.patternContext.add(tr);
            Type ch = p.pattern_.accept(new PatternVisitor<>(), arg);
            Declarations.patternExprs.remove(Declarations.patternExprs.size() - 1);
            Declarations.patternContext.remove(Declarations.patternContext.size() - 1);
            if (tr.getClass() != ch.getClass()) {
                if (tr instanceof TypeVar) {
                    if (((TypeVar) tr).stellaident_.equals("auto")) return ch;
                }
                if (ch instanceof TypeVar) {
                    if (((TypeVar) ch).stellaident_.equals("auto")) return tr;
                }
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return tr;
        }

        public Type visit(TryWith p, A arg) {
            Type tr = p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            Type ch = p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            if (tr.getClass() != ch.getClass()) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return tr;
        }

        public Type visit(Inl p, A arg) {
            if (arg != null) {
                if (Declarations.nodes.isEmpty()) {
                    throw new RuntimeException("ERROR_AMBIGUOUS_SUM_TYPE");
                }

                Object lastNode = Declarations.nodes.get(Declarations.nodes.size() - 1);

                boolean ok = lastNode instanceof DeclFun && ((DeclFun) lastNode).expr_.equals(p);
                if (lastNode instanceof TypeAsc && ((TypeAsc) lastNode).expr_.equals(p)) ok = true;
                if (lastNode instanceof Type) ok = true;


                if (!ok) throw new RuntimeException("ERROR_AMBIGUOUS_SUM_TYPE");

                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeSum)) {
                    System.exit(0);
                    throw new RuntimeException("ERROR_UNEXPECTED_INJECTION");
                }
                Type sub = p.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(((TypeSum) tp).type_1));

                if (!(sub.getClass().equals((((TypeSum) tp).type_1).getClass()))) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION ");
                }
                return tp;
            }

            if (Declarations.huiEnabled) {
                if (((TypeSum)((SomeReturnType)((DeclFun)Declarations.nodes.get(0)).returntype_).type_).type_1 instanceof TypeBottom) throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                return new TypeBottom();
            }
            throw new RuntimeException("ERROR_AMBIGUOUS_SUM_TYPE");
        }

        public Type visit(Inr p, A arg) {
            if (arg != null) {

                if (Declarations.nodes.isEmpty()) {
                    throw new RuntimeException("ERROR_AMBIGUOUS_SUM_TYPE");
                }

                Object lastNode = Declarations.nodes.get(Declarations.nodes.size() - 1);

                boolean ok = lastNode instanceof DeclFun && ((DeclFun) lastNode).expr_.equals(p);
                if (lastNode instanceof TypeAsc && ((TypeAsc) lastNode).expr_.equals(p)) ok = true;
                if (lastNode instanceof Type) ok = true;

                if (!ok) throw new RuntimeException("ERROR_AMBIGUOUS_SUM_TYPE");

                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeSum)) {
                    if (Declarations.autoEnabled) throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION ");
                    throw new RuntimeException("ERROR_UNEXPECTED_INJECTION");
                }
                Type sub = p.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(((TypeSum) tp).type_2));
                if (!(sub.getClass().equals((((TypeSum) tp).type_2).getClass()))) {
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION ");
                }
                return tp;
            }
            if (Declarations.huiEnabled) {
                if (((TypeSum)((SomeReturnType)((DeclFun)Declarations.nodes.get(0)).returntype_).type_).type_1 instanceof TypeNat) throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                return new TypeBottom();
            }
            throw new RuntimeException("Inr arg must be defined");
        }

        public Type visit(Succ p, A arg) { /* Code for Succ goes here */
            if (p.expr_.getClass().equals(Abstraction.class)) {
                throw new RuntimeException("ERROR_UNEXPECTED_LAMBDA");
            }


            Type argType = p.expr_.accept(new ExprVisitor<R, A>(), arg);
            if (!argType.getClass().equals(TypeNat.class)) {
                if (Declarations.isAuto(argType)) return new TypeNat();
                if (argType.getClass().equals(TypeTuple.class)) throw new RuntimeException("ERROR_UNEXPECTED_TUPLE");
                if (argType.getClass().equals(TypeRecord.class)) throw new RuntimeException("ERROR_UNEXPECTED_RECORD");
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION succ argument expected to be Nat");
            }
            return new TypeNat();
        }

        public Type visit(LogicNot p, A arg) { /* Code for LogicNot goes here */
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(Pred p, A arg) { /* Code for Pred goes here */
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(IsZero p, A arg) { /* Code for IsZero goes here */
            Type ex = p.expr_.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(new TypeNat()));
            if (!(ex.getClass().equals(TypeNat.class))) {
                if (Declarations.isAuto(ex)) {
                    return new TypeBool();
                }
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            return new TypeBool();
        }

        public Type visit(Fix p, A arg) { /* Code for Fix goes here */
            Type tp = p.expr_.accept(new ExprVisitor<R, A>(), null);
            if (!(tp instanceof TypeFun)) {
                throw new RuntimeException("ERROR_NOT_A_FUNCTION");
            }
            TypeFun tpFun = ((TypeFun) tp);
            Type retType = tpFun.listtype_.get(0);
            if (arg != null && !((SomeReturnType) arg).type_.equals(retType)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }
            Type kek = tpFun.type_;
            if (!retType.equals(kek)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
            }

            return retType;
        }

        public Type visit(NatRec p, A arg) { /* Code for NatRec goes here */
            Type a = p.expr_1.accept(new ExprVisitor<R, ReturnType>(), new SomeReturnType(new TypeNat()));
            Type b = p.expr_2.accept(new ExprVisitor<R, A>(), null);
            SomeReturnType currentReturnType = new SomeReturnType(new TypeFun(new ListType(), new TypeFun(new ListType(), b)));

            ((TypeFun) currentReturnType.type_).listtype_.add(new TypeNat());
            ((TypeFun) ((TypeFun) currentReturnType.type_).type_).listtype_.add(b);
            Type c = p.expr_3.accept(new ExprVisitor<R, ReturnType>(), currentReturnType);
            if (!(a.getClass().equals(TypeNat.class))) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION first parameter of Nat::rec must be Nat");
            }

            if (!(c.getClass()).equals(TypeFun.class)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION third parameter of Nat::rec must be function");
            }

            TypeFun rec = (TypeFun) c;

            if (!rec.listtype_.get(0).getClass().equals(TypeNat.class)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_PARAMETER first param of accumulator function " +
                        "of Nat::rec must be of Nat type");
            }

            if (!rec.type_.getClass().equals(TypeFun.class)) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION third parameter of Nat::rec must be function");

            }

            rec = (TypeFun) rec.type_;

            if (!rec.listtype_.get(0).getClass().equals(b.getClass())) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_PARAMETER second param of accumulator function " +
                        "of Nat::rec type mismatch");
            }

            if (!rec.type_.getClass().equals(b.getClass())) {
                throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION third parameter of Nat::rec must be function");

            }
            return b;
        }

        public Type visit(Fold p, A arg) { /* Code for Fold goes here */
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(Unfold p, A arg) { /* Code for Unfold goes here */
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        public Type visit(ConstTrue p, A arg) { /* Code for ConstTrue goes here */
            if (arg != null) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeBool || tp instanceof TypeTop)) {
                    if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                    if (tp instanceof TypeVar && ((TypeVar) tp).stellaident_.equals("auto")) {
                        ((SomeReturnType) arg).type_ = new TypeBool();
                        return ((SomeReturnType) arg).type_;
                    }
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
                return tp;
            }
            return new TypeBool();
        }

        public Type visit(ConstFalse p, A arg) { /* Code for ConstFalse goes here */
            if (arg != null) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeBool || tp instanceof TypeTop)) {
                    if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                    if (tp instanceof TypeVar && ((TypeVar) tp).stellaident_.equals("auto")) {
                        ((SomeReturnType) arg).type_ = new TypeBool();
                        return ((SomeReturnType) arg).type_;
                    }
                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
            }
            return new TypeBool();
        }

        public Type visit(ConstUnit p, A arg) { /* Code for ConstUnit goes here */
            if (arg != null) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeUnit || tp instanceof TypeTop)) {
                    if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");

                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
            }
            return new TypeUnit();
        }

        public Type visit(ConstInt p, A arg) { /* Code for ConstInt goes here */
            if (arg != null) {
                Type tp = ((SomeReturnType) arg).type_;
                if (!(tp instanceof TypeNat || tp instanceof TypeTop)) {
                    if (tp instanceof TypeVar) {
                        if (((TypeVar) tp).stellaident_.equals("auto")) {
                            ((SomeReturnType) arg).type_ = new TypeNat();
                            return ((SomeReturnType) arg).type_;
                        }
                    }
                    if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");

                    throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
                return tp;
            }
            return new TypeNat();
        }

        public Type visit(ConstMemory p, A arg) {
            if (arg == null || Declarations.isAuto(((SomeReturnType) arg).type_)) {
                return new TypeRef(new TypeNat());
            }
            if (!(((SomeReturnType) arg).type_ instanceof TypeRef)) {
                throw new RuntimeException("ERROR_UNEXPECTED_MEMORY_ADDRESS");
            }
            return ((SomeReturnType) arg).type_;
        }

        public Type visit(Var p, A arg) {
            Type tp;
            tp = Declarations.declVars.stream().filter(x -> x.getClass().equals(AParamDecl.class))
                    .map(x -> (AParamDecl) x)
                    .filter(x -> x.stellaident_.equals(p.stellaident_))
                    .map(x -> x.type_)
                    .reduce((x, y) -> y)
                    .orElse(null);
            if (tp == null) {
                tp = Declarations.declFuns.stream().filter(x -> x.stellaident_.equals(p.stellaident_))
                        .map(x -> {
                            ListType lstType = new ListType();
                            lstType.add(((AParamDecl) x.listparamdecl_.get(0)).type_);
                            return new TypeFun(lstType, ((SomeReturnType) x.returntype_).type_);
                        })
                        .findFirst().orElse(null);
            }

            if (tp == null) throw new RuntimeException("ERROR_UNDEFINED_VARIABLE");
            if (arg != null) {
                Type tip = ((SomeReturnType) arg).type_;
                if (!tp.equals(tip)) {
                    if (tp instanceof TypeVar && ((TypeVar) tp).stellaident_.equals("auto")) {
                        ((SomeReturnType)arg).type_ = tip;
                        return ((SomeReturnType)arg).type_;
                    }
                    if (tip instanceof TypeVar && ((TypeVar) tip).stellaident_.equals("auto")) return tp;
                    if (Declarations.subtypeEnabled) throw new RuntimeException("ERROR_UNEXPECTED_SUBTYPE");
                    else throw new RuntimeException("ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION");
                }
            }
            return tp;
        }
    }

    public class PatternBindingVisitor<R, A> implements PatternBinding.Visitor<R, A> {
        public R visit(APatternBinding p, A arg) { /* Code for APatternBinding goes here */
            p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }
    }

    public class VariantFieldTypeVisitor<R, A> implements VariantFieldType.Visitor<R, A> {
        public R visit(AVariantFieldType p, A arg) { /* Code for AVariantFieldType goes here */
            //p.stellaident_;
            p.optionaltyping_.accept(new OptionalTypingVisitor<R, A>(), arg);
            return null;
        }
    }

    public class RecordFieldTypeVisitor<R, A> implements RecordFieldType.Visitor<R, A> {
        public R visit(ARecordFieldType p, A arg) { /* Code for ARecordFieldType goes here */
            //p.stellaident_;
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }

    public class TypingVisitor<R, A> implements Typing.Visitor<R, A> {
        public R visit(ATyping p, A arg) { /* Code for ATyping goes here */
            p.expr_.accept(new ExprVisitor<R, A>(), arg);
            p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }
}
